// d0[i] : i 번째 자리 이친수 일때 끝자리가 0일 경우
// d1[i] : i 번째 자리 이친수 일때 끝자리가 1일 경우
// 끝자리가 1일 경우 0만 추가될 수 있다.  -->  d1[i] = d0[i-1]
// 끝자리가 0일 경우 0,1이 추가될 수 있다. --> d0[i] = d0[i-1]+d1[i-1]
// bottom - up : 상향식 문제 작은것부터 문제 해결 및 주로 for문 이용

// 공식 풀이
// d[n] = n 자리 이친수
// n번째 자리에 0 : d[n-1]
// n번째 자리에 1 : 1이 올시엔 무조건 그 전자리가 0 그전자리가(d[n-1]) 0인 이친수의 갯수는 d[n-2]
#include <bits/stdc++.h>

long long d0[91];
long long d1[91];
int main() {
	int n;
	scanf("%d", &n);
	d0[1] = 0;
	d1[1] = 1;
	if(n>=2)
		for (int i = 2; i <= n; i++) {
			d1[i] = d0[i - 1];
			d0[i] = d0[i - 1] + d1[i - 1];
		}
	printf("%lld", d0[n] + d1[n]); //90 까지할려면 longlong필요
}